from __future__ import annotations
from .creator_handle import CreatorHandle, CreatorHandleSet
from .identifier import StateElementIdentifier, RetrievalType
from .osp_reader import OspSpeciesReader
from .retrieval_array import FullGridMappedArray, RetrievalGrid2dArray
from pathlib import Path
from loguru import logger
import numpy as np
import abc
import typing

if typing.TYPE_CHECKING:
    from .muses_observation import ObservationHandleSet, MeasurementId
    from .retrieval_configuration import RetrievalConfiguration
    from .muses_strategy import MusesStrategy, CurrentStrategyStep
    from .current_state import (
        StateElement,
        SoundingMetadata,
        RetrievalGridArray,
    )


class CrossStateElement:
    """This handles cross state elements (e.g., H2O-HDO).

    Note that the design for this may well need to be updated. We
    currently have exactly one example of an "interesting" cross term
    - the H2O-HDO cross term. It is a bit hard to determine if we have
    the right interfaces/abstractions with just one example. But this
    is at least our current best guess at how to organize this, and is
    hopefully a good base for tweaking if we get more examples.

    There are 3 primary things we need to be able to do:

    1. Provide updates to the constraint matrix used in the
       CostFunction. This both updates the non cross terms (e.g., the
       H2O part of the constraint matrix, which uses a different set
       of values when we have a cross term - e.g., some of the signal
       for H2O gets moved into HDO), and handles the cross term part
       of the covariance (e.g., the H2O-HDO block).

    2. Handle any coupling when we do updates (e.g., when H2O but not
       HDO is part of a retrieval we update HDO when H2O changes).

    3. Handle the cross terms in the aposteriori covariance matrix for
       the forward model generated by the ErrorAnalysis, which then
       gets used in future retrieval steps in the ErrorAnalysis

    Note that right now, we don't have any cross terms in the apriori
    covariance matrix.  While we could in principle, we don't actually
    have any. We don't currently provide support for this - not
    because we might not need this in the future but since we don't
    have any examples we don't really know how to set this up. If we
    have cross terms in the future, we'll need to think through how to
    handle this and include it. Probably (but not certainly) similar
    to how we handle the constraint matrix.

    Like with StateElement, a CrossStateElement gets notified when various things
    happen in a retrieval. These are:

    1. notify_start_retrieval called at the very start of a retrieval. So this can
       do things like update the value and step_initial_fm to the retrieval_initial_fm.
    2. notify_start_step called at the start of a retrieval step. So this can do
       things like update the value and step_initial_fm to the next_step_initial_fm
       determined in the previous step
    3. notify_step_solution called when a retrieval step reaches a solution. This can
       determine the step_initial_fm for the next step.
    4. Note, we *don't* have notify_parameter_update like we do for StateElement. This just
       didn't seem useful, so we didn't put that in. If this actually ends up being something
       that we would be useful, we could easily add that in.

    Note that the StateElement have already received the notify messages, so for example
    in notify_step_solution you can depend on any StateElement you reference already has
    been updated by a call to its notify_step_solution.
    """

    def __init__(
        self,
        state_element_id_1: StateElementIdentifier,
        state_element_id_2: StateElementIdentifier,
    ) -> None:
        """Constructor, taking the two state elements ids that we are handling the
        cross term for.

        Note as a convention we always order the state element by
        StateElementIdentifier.sort_identifier. This means that for example H2O/HDO will
        always have H2O as state_element_id_1 and HDO and state_element_id_2."""
        # Sort if needed
        self.state_element_id_1, self.state_element_id_2 = (
            StateElementIdentifier.sort_identifier(
                [state_element_id_1, state_element_id_2]
            )
        )

    def cross_constraint_matrix(
        self,
    ) -> tuple[
        RetrievalGrid2dArray | None,
        RetrievalGrid2dArray | None,
        RetrievalGrid2dArray | None,
    ]:
        """Return a tuple, one for the cross term state_element_id_1 x
        state_element_id_1, one for state_element_id_1 x
        state_element_id_2 and one for state_element_id_2 x
        state_element_id_2.

        Note any or all of these can be "None", which means don't
        change the cross term constraint matrix. In particular for the
        state_element_id_1 x state_element_id_1 and state_element_id_2
        x state_element_id_2 that means use the constraint_matrix
        returned by those StateElement without change.

        """
        return (None, None, None)

    def notify_start_retrieval(
        self,
        current_strategy_step: CurrentStrategyStep | None,
        retrieval_config: RetrievalConfiguration,
    ) -> None:
        """Called at the start of a retrieval (before the first step). The StateElements that
        make up this cross term have already had notify_start_retrieval called on them."""
        pass

    def notify_start_step(
        self,
        current_strategy_step: CurrentStrategyStep,
        retrieval_config: RetrievalConfiguration,
        skip_initial_guess_update: bool = False,
    ) -> None:
        """Called each time at the start of a retrieval step.  The StateElements that make
        up this cross term have already had notify_start_step called on them."""
        pass

    def notify_step_solution(
        self,
        xsol: RetrievalGridArray,
        retrieval_slice_selem_1: slice | None,
        retrieval_slice_selem_2: slice | None,
    ) -> None:
        """Called when a retrieval step has a solution.

        Note the StateElement have all been updated already, so if we need to update
        something due to coupling (e.g., HDO for H2O update) the state elements have already
        been updated (so you can read the value from H2O).

        We pass in the slice needed to get this the StateElement
        values for the two StateElements in this cross term, or None
        if we aren't actually retrieving one of the StateElements. It
        just is more natural to have something outside this class
        maintain this information (e.g the CurrentState), since this
        depends on access to all the StateElement in the StateInfo.

        """
        pass


class CrossStateElementHandle(CreatorHandle):
    """Return CrossStateElement objects, for a given pair of StateElement

    Note CrossStateElementHandle can assume that they are called for
    the same target, until notify_update_target is called. So if it
    makes sense, these objects can do internal caching for things that
    don't change when the target being retrieved is the same from one
    call to the next.

    """

    def notify_update_target(
        self,
        measurement_id: MeasurementId,
        retrieval_config: RetrievalConfiguration,
        strategy: MusesStrategy,
        observation_handle_set: ObservationHandleSet,
        sounding_metadata: SoundingMetadata,
    ) -> None:
        """Clear any caching associated with assuming the target being retrieved is fixed"""
        # Default is to do nothing
        pass

    @abc.abstractmethod
    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement | None:
        raise NotImplementedError()


class CrossStateElementHandleSet(CreatorHandleSet):
    """This maps a StateElementIdentifier to a StateElement object that handles it.

    Note StatElementHandle can assume that they are called for the same target, until
    notify_update_target is called. So if it makes sense, these objects can do internal
    caching for things that don't change when the target being retrieved is the same from
    one call to the next."""

    def __init__(self) -> None:
        super().__init__("cross_state_element")

    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement:
        if state_element_1.state_element_id < state_element_2.state_element_id:
            return self.handle(state_element_1, state_element_2)
        else:
            return self.handle(state_element_2, state_element_1)

    def notify_update_target(
        self,
        measurement_id: MeasurementId,
        retrieval_config: RetrievalConfiguration,
        strategy: MusesStrategy,
        observation_handle_set: ObservationHandleSet,
        sounding_metadata: SoundingMetadata,
    ) -> None:
        """Clear any caching associated with assuming the target being retrieved is fixed"""
        for p in sorted(self.handle_set.keys(), reverse=True):
            for h in self.handle_set[p]:
                h.notify_update_target(
                    measurement_id,
                    retrieval_config,
                    strategy,
                    observation_handle_set,
                    sounding_metadata,
                )


class CrossStateElementImplementation(CrossStateElement):
    def __init__(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> None:
        if state_element_1.state_element_id < state_element_2.state_element_id:
            self._state_element_1 = state_element_1
            self._state_element_2 = state_element_2
        else:
            self._state_element_1 = state_element_2
            self._state_element_2 = state_element_1
        super().__init__(
            self._state_element_1.state_element_id,
            self._state_element_2.state_element_id,
        )


class CrossStateElementDefaultHandle(CrossStateElementHandle):
    def __init__(self) -> None:
        pass

    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement | None:
        # Don't bother logging these. We have tons of these, and they aren't very
        # interesting. We just log the ones that are interesting
        if False:
            logger.debug(
                f"Creating CrossStateElementDefault for {state_element_1.state_element_id} x {state_element_2.state_element_id}"
            )
        return CrossStateElementImplementation(state_element_1, state_element_2)


class H2OCrossStateElementOsp(CrossStateElementImplementation):
    """Handle the H2O x HDO cross term"""

    def __init__(
        self,
        state_element_1: StateElement,
        state_element_2: StateElement,
        species_directory: Path,
    ) -> None:
        super().__init__(state_element_1, state_element_2)
        self.osp_species_reader = OspSpeciesReader.read_dir(species_directory)
        self.retrieval_type = RetrievalType("default")
        self._retrieve_both = False
        self._retrieve_first = False

    def cross_constraint_matrix(
        self,
    ) -> tuple[
        RetrievalGrid2dArray | None,
        RetrievalGrid2dArray | None,
        RetrievalGrid2dArray | None,
    ]:
        # Only update if we have a cross term
        if not self._retrieve_both:
            return (None, None, None)
        cm1 = self.osp_species_reader.read_constraint_matrix(
            self.state_element_id_1,
            self.retrieval_type,
            self._state_element_1.basis_matrix.shape[0],
            sid2=self.state_element_id_1,
        ).view(RetrievalGrid2dArray)
        cm2 = self.osp_species_reader.read_constraint_matrix(
            self.state_element_id_1,
            self.retrieval_type,
            self._state_element_1.basis_matrix.shape[0],
            sid2=self.state_element_id_2,
        ).view(RetrievalGrid2dArray)
        cm3 = self.osp_species_reader.read_constraint_matrix(
            self.state_element_id_2,
            self.retrieval_type,
            self._state_element_2.basis_matrix.shape[0],
            sid2=self.state_element_id_2,
        ).view(RetrievalGrid2dArray)
        # TODO Change this
        # To match the old py-retrieve code, we convert to and from float32
        cm1 = cm1.astype(np.float32).astype(float).view(RetrievalGrid2dArray)
        cm2 = cm2.astype(np.float32).astype(float).view(RetrievalGrid2dArray)
        cm3 = cm3.astype(np.float32).astype(float).view(RetrievalGrid2dArray)
        return (cm1, cm2, cm3)

    def notify_start_step(
        self,
        current_strategy_step: CurrentStrategyStep,
        retrieval_config: RetrievalConfiguration,
        skip_initial_guess_update: bool = False,
    ) -> None:
        super().notify_start_step(
            current_strategy_step,
            retrieval_config,
            skip_initial_guess_update,
        )
        self.retrieval_type = current_strategy_step.retrieval_type
        self._retrieve_both = False
        if (
            self.state_element_id_1 in current_strategy_step.retrieval_elements
            and self.state_element_id_2 in current_strategy_step.retrieval_elements
        ):
            self._retrieve_both = True
        self._retrieve_first = (
            self.state_element_id_1 in current_strategy_step.retrieval_elements
        )

    def notify_step_solution(
        self,
        xsol: RetrievalGridArray,
        retrieval_slice_selem_1: slice | None,
        retrieval_slice_selem_2: slice | None,
    ) -> None:
        # If we retrieve H2O but not HDO, then update HDO to maintain the ratio with
        # H2O
        if not self._retrieve_both and self._retrieve_first:
            logger.debug(
                f"In H2OCrossStateElementOsp, updating {self.state_element_id_2} to maintain the ratio with {self.state_element_id_1}"
            )
            v = (
                self._state_element_1.value_fm
                * (
                    self._state_element_2.step_initial_fm
                    / self._state_element_1.step_initial_fm
                )
            ).view(FullGridMappedArray)
            self._state_element_2.update_state_element(
                value_fm=v, next_step_initial_fm=v
            )


class H2OCrossStateElementOspHandle(CrossStateElementHandle):
    def __init__(
        self, sid_1: StateElementIdentifier, sid_2: StateElementIdentifier
    ) -> None:
        self.sid_1 = sid_1
        self.sid_2 = sid_2
        self.retrieval_config: RetrievalConfiguration | None = None

    def notify_update_target(
        self,
        measurement_id: MeasurementId,
        retrieval_config: RetrievalConfiguration,
        strategy: MusesStrategy,
        observation_handle_set: ObservationHandleSet,
        sounding_metadata: SoundingMetadata,
    ) -> None:
        self.measurement_id = measurement_id
        self.retrieval_config = retrieval_config
        self.strategy = strategy
        self.observation_handle_set = observation_handle_set
        self.sounding_metadata = sounding_metadata

    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement | None:
        if (
            state_element_1.state_element_id != self.sid_1
            or state_element_2.state_element_id != self.sid_2
        ):
            return None
        if self.retrieval_config is None:
            raise RuntimeError("Need to call notify_update_target first")
        res = H2OCrossStateElementOsp(
            state_element_1,
            state_element_2,
            Path(self.retrieval_config["speciesDirectory"]),
        )
        if res is not None:
            logger.debug(
                f"Creating H2OCrossStateElementOsp for {self.sid_1} x {self.sid_2} cross state element"
            )
        return res


# Handle the H2O cross terms
CrossStateElementHandleSet.add_default_handle(
    H2OCrossStateElementOspHandle(
        StateElementIdentifier("H2O"), StateElementIdentifier("HDO")
    )
)
CrossStateElementHandleSet.add_default_handle(
    H2OCrossStateElementOspHandle(
        StateElementIdentifier("H2O"), StateElementIdentifier("H2018")
    )
)
CrossStateElementHandleSet.add_default_handle(
    H2OCrossStateElementOspHandle(
        StateElementIdentifier("H2O"), StateElementIdentifier("H2017")
    )
)

# Fall back to our default handle. Note the vast majority of the cross terms will be this
# type, we only have one example right now of a "interesting" cross term - the H2O x HDO term.
CrossStateElementHandleSet.add_default_handle(
    CrossStateElementDefaultHandle(), priority_order=-1
)

__all__ = [
    "CrossStateElement",
    "CrossStateElementHandle",
    "CrossStateElementHandleSet",
    "CrossStateElementImplementation",
    "CrossStateElementDefaultHandle",
]
