from __future__ import annotations
from .creator_handle import CreatorHandle, CreatorHandleSet
from .identifier import StateElementIdentifier
from loguru import logger
import abc
import typing

if typing.TYPE_CHECKING:
    from .muses_observation import ObservationHandleSet, MeasurementId
    from .retrieval_configuration import RetrievalConfiguration
    from .muses_strategy import MusesStrategy
    from .current_state import RetrievalGrid2dArray, StateElement, SoundingMetadata


class CrossStateElement:
    """This handles cross state elements (e.g., H2O-HDO).

    Note that the design for this may well need to be updated. We
    currently have exactly one example of an "interesting" cross term
    - the H2O-HDO cross term. It is a bit hard to determine if we have
    the right interfaces/abstractions with just one example. But this
    is at least our current best case at how to organize this, and is
    hopefully a good base for tweaking if we get more examples.

    There are 3 primary things we need to be able to do:

    1. Provide updates to the constraint matrix used in the
       CostFunction. This both updates the non cross terms (e.g., the
       H2O part of the constraint matrix, which uses a different set
       of values when we have a cross term - e.g., some of the signal
       for H2O gets moved into HDO), and handles the cross term part
       of the covariance (e.g., the H2O-HDO block).

    2. Handle any coupling when we do updates (e.g., when H2O but not
       HDO is part of a retrieval we update HDO when H2O changes).

    3. Handle the cross terms in the aposteriori covariance matrix for
       the forward model generated by the ErrorAnalysis, which then
       gets used in future retrieval steps in the ErrorAnalysis

    Note that right now, we don't have any cross terms in the apriori
    covariance matrix.  While we could in principle, we don't actually
    have any. We don't currently provide support for this - not
    because we might not need this in the future but since we don't
    have any examples we don't really know how to set this up. If we
    have cross terms in the future, we'll need to think through how to
    handle this and include it. Probably (but not certainly) similar
    to how we handle the constraint matrix.
    """

    def __init__(
        self,
        state_element_id_1: StateElementIdentifier,
        state_element_id_2: StateElementIdentifier,
    ) -> None:
        """Constructor, taking the two state elements ids that we are handling the
        cross term for.

        Note as a convention we always order the state element by
        StateElementIdentifier.sort_identifier. This means that for example H2O/HDO will
        always have H2O as state_element_id_1 and HDO and state_element_id_2."""
        # Sort if needed
        self.state_element_id_1, self.state_element_id_2 = (
            StateElementIdentifier.sort_identifier(
                [state_element_id_1, state_element_id_2]
            )
        )

    def cross_constraint_matrix(
        self,
    ) -> tuple[
        RetrievalGrid2dArray | None,
        RetrievalGrid2dArray | None,
        RetrievalGrid2dArray | None,
    ]:
        """Return a tuple, one for the cross term state_element_id_1 x
        state_element_id_1, one for state_element_id_1 x
        state_element_id_2 and one for state_element_id_2 x
        state_element_id_2. Note any or all of these can be "None",
        which means don't change the cross term constraint matrix. In
        particular for the state_element_id_1 x state_element_id_1 and
        state_element_id_2 x state_element_id_2 that means use the
        constraint_matrix returned by those StateElement without
        change."""
        return (None, None, None)


class CrossStateElementHandle(CreatorHandle):
    """Return CrossStateElement objects, for a given pair of StateElement

    Note CrossStateElementHandle can assume that they are called for
    the same target, until notify_update_target is called. So if it
    makes sense, these objects can do internal caching for things that
    don't change when the target being retrieved is the same from one
    call to the next.

    """

    def notify_update_target(
        self,
        measurement_id: MeasurementId,
        retrieval_config: RetrievalConfiguration,
        strategy: MusesStrategy,
        observation_handle_set: ObservationHandleSet,
        sounding_metadata: SoundingMetadata,
    ) -> None:
        """Clear any caching associated with assuming the target being retrieved is fixed"""
        # Default is to do nothing
        pass

    @abc.abstractmethod
    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement | None:
        raise NotImplementedError()


class CrossStateElementHandleSet(CreatorHandleSet):
    """This maps a StateElementIdentifier to a StateElement object that handles it.

    Note StatElementHandle can assume that they are called for the same target, until
    notify_update_target is called. So if it makes sense, these objects can do internal
    caching for things that don't change when the target being retrieved is the same from
    one call to the next."""

    def __init__(self) -> None:
        super().__init__("cross_state_element")

    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement:
        if state_element_1.state_element_id < state_element_2.state_element_id:
            return self.handle(state_element_1, state_element_2)
        else:
            return self.handle(state_element_2, state_element_1)

    def notify_update_target(
        self,
        measurement_id: MeasurementId,
        retrieval_config: RetrievalConfiguration,
        strategy: MusesStrategy,
        observation_handle_set: ObservationHandleSet,
        sounding_metadata: SoundingMetadata,
    ) -> None:
        """Clear any caching associated with assuming the target being retrieved is fixed"""
        for p in sorted(self.handle_set.keys(), reverse=True):
            for h in self.handle_set[p]:
                h.notify_update_target(
                    measurement_id,
                    retrieval_config,
                    strategy,
                    observation_handle_set,
                    sounding_metadata,
                )


class CrossStateElementImplementation(CrossStateElement):
    def __init__(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> None:
        if state_element_1.state_element_id < state_element_2.state_element_id:
            self._state_element_1 = state_element_1
            self._state_element_2 = state_element_2
        else:
            self._state_element_1 = state_element_2
            self._state_element_2 = state_element_1
        super().__init__(
            self._state_element_1.state_element_id,
            self._state_element_2.state_element_id,
        )


class CrossStateElementDefaultHandle(CrossStateElementHandle):
    def __init__(self) -> None:
        pass

    def cross_state_element(
        self, state_element_1: StateElement, state_element_2: StateElement
    ) -> CrossStateElement | None:
        # Don't bother logging these. We have tons of these, and they aren't very
        # interesting. We just log the ones that are interesting
        if False:
            logger.debug(
                f"Creating CrossStateElementDefault for {state_element_1.state_element_id} x {state_element_2.state_element_id}"
            )
        return CrossStateElementImplementation(state_element_1, state_element_2)


# Fall back to our default handle. Note the vast majority of the cross terms will be this
# type, we only have one example right now of a "interesting" cross term - the H2O x HDO term.
CrossStateElementHandleSet.add_default_handle(
    CrossStateElementDefaultHandle(), priority_order=-1
)

__all__ = [
    "CrossStateElement",
    "CrossStateElementHandle",
    "CrossStateElementHandleSet",
    "CrossStateElementImplementation",
    "CrossStateElementDefaultHandle",
]
