#!/usr/bin/env python 
import click
import logging
import subprocess
import os
from refractor.muses import RefractorUip, MusesRunDir, MusesRetrievalStep
import refractor.muses.muses_py as mpy
import shutil
import h5py
import glob

logger = logging.getLogger('refractor.muses')
# Setup logging
class ColorLogFormatter(logging.Formatter):
    '''Set logging format, optionally with color'''
    def __init__(self, add_color = True):
        self.add_color = add_color

    def color_text(self, text, levelno):
        # ANSI colors
        HEADER = '\033[95m'
        OKBLUE = '\033[94m'
        OKGREEN = '\033[92m'
        WARNING = '\033[93m'
        FAIL = '\033[91m'
        ENDC = '\033[0m'
        BOLD = '\033[1m'
        UNDERLINE = '\033[4m'
        if(not self.add_color):
            return text
        if(levelno == logging.DEBUG):
            return OKBLUE + text + ENDC
        elif(levelno == logging.INFO):
            return OKGREEN + text + ENDC
        elif(levelno == logging.WARNING):
            return WARNING + text + ENDC
        elif(levelno == logging.ERROR):
            return FAIL + text + ENDC
        elif(levelno == logging.CRITICAL):
            return FAIL + text + ENDC
        return text
    def format(self, record):
        return (self.color_text(record.levelname + " " +
                                self.formatTime(record) +
                                ": ", record.levelno) + record.getMessage())

loglevel = logging.INFO
h = logging.StreamHandler()
h.setLevel(loglevel)
h.setFormatter(ColorLogFormatter(add_color=True))
logger.addHandler(h)
logger.setLevel(loglevel)

def amuse_me_path():
    '''Determine the amuse_me path, and also do some basic checks.'''
    try:
        r = subprocess.run(["which", "amuse-me"], check=True,
                           capture_output=True)
    except:
        logger.error("Unable to find amuse-me from environment PATH")
        exit(1)
    return r.stdout.decode('utf-8').rstrip()

def program_root():
    '''Base used to find various programs.'''
    return os.path.dirname(os.path.dirname(os.path.dirname(amuse_me_path())))

def check_osp_path():
    '''Check that MUSES_OSP_PATH is set'''
    if not "MUSES_OSP_PATH" in os.environ:
        logger.error("Please set the MUSES_OSP_PATH environment variable to point to the OSP root directory")
        exit(1)

def sounding_dir(instrument, sounding, output_dir="./output"):
    res = os.path.abspath(output_dir)
    if(instrument == "omi"):
        res += "/omi/2016-04-14/setup-targets/Global_Survey/"
    elif(instrument == "tropomi"):
        res += "/tropomi/2019-08-07/setup-targets/Global_Survey_Grid_4.0/"
    elif(instrument == "cris_tropomi"):
        res += "/cris_tropomi/2019-08-07/setup-targets/Global_Survey_Grid_4.0/"
    elif(instrument == "airs_omi"):
        res += "/airs_omi/2016-04-01/setup-targets/Western_Boundary/"
    else:
        logger.error(f"Unrecognized instrument type {instrument}, should be one of 'omi' or 'tropomi'")
    res += sounding
    return res

def cloud_fraction_dict(instrument, output_dir="./output"):
    cloud_fraction_data = {}
    res = {}
    for slist in glob.glob(sounding_dir(instrument, "2*", output_dir=output_dir)):
        _, d = mpy.read_all_tes(f"{slist}/Measurement_ID.asc")
        sid = d['preferences']["SOUNDINGID"]
        if(instrument in ("tropomi", "cris_tropomi")):
            cfname = d['preferences']["TROPOMI_Cloud_filename"]
            if(cfname not in cloud_fraction_data):
                fh = h5py.File(cfname)
                cloud_fraction_data[cfname] = fh["PRODUCT/cloud_fraction"][0,:,:]
                fh.close()
            atrack = int(d['preferences']["TROPOMI_ATrack_Index"])
            xtrack = int(d['preferences']["TROPOMI_XTrack_Index_BAND3"])
            res[sid] = cloud_fraction_data[cfname][atrack,xtrack]
        else:
            raise RuntimeError("Unrecognized instrument type")
    return res


def base_command(instrument,output_dir="./output"):
    '''The part of the amuse_me command that is in common for
    setup-targets and run-retrieval'''
    check_osp_path()
    # Note, you can look at examples at
    # https://github.jpl.nasa.gov/MUSES-Processing/amuse-me/blob/develop/docs/examples.md.
    # We run one day in each case, the day that we grab the test sounding
    # for. For right now, we use the same soundings as used in the
    # py-retrieve smoke tests.
    
    cmd = [amuse_me_path(),
           "--output", os.path.abspath(output_dir),
           "--clear-output",
           "--OSP", os.environ["MUSES_OSP_PATH"],
           "--programs", program_root(),
           "--hosts", "tb_1-2",
           "--tasks-per-host", "8",
           "--python", 
           ]
           
    if(instrument == "omi"):
        cmd.extend(["--sensor-set", "OMI",
                    "--profile", "Global_Survey",
                    "--date", "2016-04-14",
                    ])
        sounding1 = "20160414_23_394_11_23"
        step_list = [1,2]
    elif(instrument == "airs_omi"):
        cmd.extend(["--sensor-set", "AIRS_OMI",
                    "--profile", "Western_Boundary",
                    "--date", "2016-04-01",
                    ])
        # I just grabbed a sounding here, not sure how good this is
        sounding1 = "20160401_231_049_87"
        #step_list = [1,2,3,4,5,6,7,8]
        # Temp, grab the joint step. We'll get the rest also,
        # but that will take a chunk of time to run
        step_list = [7,]
    elif(instrument == "tropomi"):
        cmd.extend(["--sensor-set", "TROPOMI",
                    "--tropomi-band", "3",
                    "--profile", "Global_Survey_Grid_4.0",
                    "--date", "2019-08-07",
                    ])
        sounding1="20190807_9401_351_176"
        step_list = [1,2,3]
    elif(instrument == "cris_tropomi"):
        cmd.extend(["--sensor-set", "CrIS_TROPOMI",
                    "--profile", "Global_Survey_Grid_4.0",
                    "--date", "2019-08-07",
                    ])
        sounding1="20190807_065_03_00_4"
        # Grab just the one joint step, so we can test against that
        step_list = [10,]
    else:
        logger.error(f"Unrecognized instrument type {instrument}, should be one of 'omi', 'airs_omi', 'tropomi', or 'cris_tropomi'")
    return cmd, [sounding1,], step_list
        
@click.group()
def cli():
    '''This is various utility routines for running the MUSES pipeline,
    which we then separately capture with capture tests in the instrument
    repositories.

    See README.md for more details.
    '''
    pass

@cli.command()
@click.argument("instrument", type=str)
@click.option("--output-dir", default="./output",
              help="Location the output of amuse-me goes")
def setup_targets(instrument, output_dir="./output"):
    '''Run the pipeline through the setup_targets step. Use the
    instrument name "all" to run all instruments'''
    # Note, you can look at examples at
    # https://github.jpl.nasa.gov/MUSES-Processing/amuse-me/blob/develop/docs/examples.md.
    # We run one day in each case, the day that we grab the test sounding
    # for. For right now, we use the same soundings as used in the
    # py-retrieve smoke tests. 
    logger.info("In setup-targets")
    ilist = (instrument,)
    if(instrument == "all"):
        ilist = ("omi", "tropomi", "airs_omi", "cris_tropomi")
    for inst in ilist:
        cmd, _, _ = base_command(inst,output_dir=output_dir)
        cmd.extend(["--start-step", "geolocate",
                    "--end-step", "setup_targets"])
        logger.info(f'Running: {" ".join(cmd)}')
        subprocess.run(cmd, check=True)

@cli.command()
@click.argument("instrument", type=str)
@click.option("--output-dir", default="./output",
              help="Location the output of amuse-me goes")
@click.option("--test-data-dir", default="../../refractor_test_data",
              help="Location where the captures data goes")
@click.option("--suppress-output/--show-output", default=True)
def capture_run(instrument,output_dir="./output",
                test_data_dir="../../refractor_test_data",suppress_output=True):
    '''Update the pickle/save files for processing the given instrument.
    Use the instrument "all" to run all the instruments'''
    logger.info("In capture-run")
    # Temporary, make sure libgfortran.so.4 is in path. See
    # https://jpl.slack.com/archives/CVBUUE5T5/p1664476320620079.
    # Note that currently omi uses muses-vlidort repository build, which
    # doesn't have this problem any longer. But tropomi does still
    os.environ["LD_LIBRARY_PATH"] = f"{os.environ['CONDA_PREFIX']}/lib:{os.environ['LD_LIBRARY_PATH']}"
    os.environ["MUSES_PYOSS_LIBRARY_DIR"] = mpy.pyoss_dir
    
    ilist = (instrument,)
    if(instrument == "all"):
        ilist = ("omi", "tropomi", "airs_omi", "cris_tropomi")
    for inst in ilist:
        _, sounding_list, step_list = base_command(inst,output_dir=output_dir)
        for i, sounding in enumerate(sounding_list):
            capoutdir = f"{os.path.abspath(test_data_dir)}/{inst}/in/sounding_{i+1}"
            logger.info(f"Writing output to {capoutdir}")
            sdir = sounding_dir(inst, sounding,output_dir=output_dir)
            MusesRunDir.save_run_directory(sdir, capoutdir)
            with open(f"{capoutdir}/sounding.txt", "w") as fh:
                print(sounding, file=fh)
            fname =  f"{sdir}/Table.asc"
            for step_number in step_list:
                logger.info(f"Capturing UIP for step {step_number}")
                _ = RefractorUip.create_from_table(fname, step=step_number,
                     capture_directory=True,
                     save_pickle_file=f"{capoutdir}/uip_step_{step_number}.pkl",
                     suppress_noisy_output=suppress_output)
                logger.info(f"Capturing MusesRetrievalStep for step {step_number}")
                _ = MusesRetrievalStep.create_from_table(fname, step=step_number,
                     capture_directory=True,
                     save_pickle_file=f"{capoutdir}/run_retrieval_step_{step_number}.pkl",
                     suppress_noisy_output=suppress_output)
    
@cli.command()
@click.argument("instrument", type=str)
@click.option("--output-dir", default="./output",
              help="Location the output of amuse-me goes")
@click.option("--refractor-config", default=None,
              help="If supplied, use refractor and the given config file")
def run_retrieval(instrument, refractor_config = None,
                  output_dir="./output"):
    '''Run the retrieval on a single sounding. '''
    logger.info("In run-retrival")
    cmd, soundings, _ = base_command(instrument, output_dir=output_dir)
    if(refractor_config is not None):
        cmd.extend(["--refractor", "--refractor-config", refractor_config])
    cmd.extend(["--start-step", "retrieve_one",
                "--end-step", "retrieve_one",
                "--retrieve-one", soundings[0]])
    logger.info(f'Running: {" ".join(cmd)}')
    # Temporary, make sure libgfortran.so.4 is in path. See
    # https://jpl.slack.com/archives/CVBUUE5T5/p1664476320620079.
    # Note that currently omi uses muses-vlidort repository build, which
    # doesn't have this problem any longer. But tropomi does still
    os.environ["LD_LIBRARY_PATH"] = f"{os.environ['CONDA_PREFIX']}/lib:{os.environ['LD_LIBRARY_PATH']}"
    subprocess.run(cmd, check=True)

@cli.command()
@click.argument("instrument", type=str)
@click.option("--output-dir", default="./output",
              help="Location the output of amuse-me goes")
def cloud_fraction(instrument, output_dir="./output"):
    '''Report cloud fraction for each sounding, can be used to select a good sounding'''
    res = cloud_fraction_dict(instrument, output_dir="./output")
    for k in sorted(res.keys()):
        print(f"{k}: {res[k]}")
    
if __name__ == '__main__':
    cli()

